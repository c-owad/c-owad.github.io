<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neuro-Structure Laboratory</title>
    <style>
        body { margin: 0; background-color: #0f0f19; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        
        /* SIDEBAR MENU */
        #sidebar {
            position: absolute; left: 0; top: 0; bottom: 0; width: 250px;
            background: rgba(0,0,0,0.8); border-right: 1px solid #333;
            padding: 20px; z-index: 20; display: flex; flex-direction: column;
        }
        h2 { color: #00ffc8; margin-top: 0; font-size: 18px; text-transform: uppercase; letter-spacing: 1px; }
        .molecule-btn {
            background: #222; border: 1px solid #444; color: #ccc;
            padding: 12px; margin-bottom: 10px; cursor: pointer;
            text-align: left; border-radius: 6px; transition: 0.2s;
        }
        .molecule-btn:hover { background: #333; border-color: #00ffc8; color: white; }
        .molecule-btn.active { background: #00ffc8; color: black; border-color: #00ffc8; font-weight: bold; }

        /* MAIN CANVAS AREA */
        #canvas-container { position: absolute; left: 250px; top: 0; right: 0; bottom: 0; }
        canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        canvas:active { cursor: grabbing; }

        /* HUD OVERLAYS */
        #hud { position: absolute; top: 20px; left: 20px; pointer-events: none; }
        #molecule-title { font-size: 24px; font-weight: bold; color: white; }
        #molecule-desc { font-size: 14px; color: #00ffc8; margin-top: 5px; max-width: 400px; }

        /* CONTROLS */
        #controls { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 10px; }
        button.action-btn {
            background: #ffd700; border: none; padding: 10px 20px;
            font-weight: bold; cursor: pointer; border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        button.action-btn:hover { background: white; }

        /* LOADING SPINNER */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; color: #00ffc8; display: none;
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <h2>Select Target</h2>
        <div id="menu-list"></div>
        <div style="margin-top: auto; font-size: 12px; color: #666;">
            Scroll to Zoom<br>Drag to Rotate
        </div>
        <a href="index.html" style="color: #666; text-decoration: none; margin-top: 10px; font-size: 12px;">‚Üê Back to Portfolio</a>
    </div>

    <div id="canvas-container">
        <div id="hud">
            <div id="molecule-title">Select a Protein</div>
            <div id="molecule-desc"></div>
        </div>
        <div id="loader">Fetching Structure...</div>
        <canvas id="simCanvas"></canvas>
        
        <div id="controls">
            <button class="action-btn" onclick="toggleSimulation()" id="simBtn">INJECT LIGAND</button>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    // UPDATE THIS URL TO YOUR RENDER URL WHEN DEPLOYING
    const API_URL = "https://one5113hw4backend.onrender.com/api/molecule"; 

    // The "Database" of proteins
    const MOLECULES = [
        { 
            name: "Dopamine Receptor", 
            id: "3PBL", 
            desc: "The 'Pleasure' receptor. Primary target for antipsychotics.",
            labels: [{text: "Ligand Pocket", x: 10, y: -5, z: 0}, {text: "Helix Bundle", x: -15, y: 10, z: 5}]
        },
        { 
            name: "Serotonin Transporter", 
            id: "5I6X", 
            desc: "Regulates mood and anxiety. Target of SSRI antidepressants.",
            labels: [{text: "Central Cavity", x: 0, y: 0, z: 0}]
        },
        { 
            name: "GABA Receptor", 
            id: "4COF", 
            desc: "The 'Calm' receptor. Activated by sedatives and alcohol.",
            labels: [{text: "Ion Channel", x: 0, y: 20, z: 0}]
        },
        { 
            name: "Adrenaline Receptor", 
            id: "3SN6", 
            desc: "Triggers the 'Fight or Flight' response.",
            labels: [{text: "G-Protein Interface", x: 0, y: -30, z: 0}]
        }
    ];

    // Colors for different chains (Cyan, Purple, Green, Orange)
    const CHAIN_COLORS = ["#00ffc8", "#bd00ff", "#00ff00", "#ff8800"];

    // --- STATE ---
    let points = [];
    let currentMolecule = null;
    let center = {x: 0, y: 0, z: 0};
    let camera = { x: 0, y: 0, scale: 14 };
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };
    
    // Animation State
    let animating = false;
    let animTime = 0;

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    // --- INITIALIZATION ---
    function init() {
        // Build Menu
        const menu = document.getElementById('menu-list');
        MOLECULES.forEach(mol => {
            const btn = document.createElement('div');
            btn.className = 'molecule-btn';
            btn.innerText = mol.name;
            btn.onclick = () => loadMolecule(mol, btn);
            menu.appendChild(btn);
        });

        // Resize Handling
        window.addEventListener('resize', resize);
        resize();

        // Start Loop
        requestAnimationFrame(draw);
    }

    function resize() {
        canvas.width = document.getElementById('canvas-container').offsetWidth;
        canvas.height = document.getElementById('canvas-container').offsetHeight;
    }

    // --- CORE LOGIC ---
    async function loadMolecule(mol, btnElement) {
        // UI Updates
        document.querySelectorAll('.molecule-btn').forEach(b => b.classList.remove('active'));
        if(btnElement) btnElement.classList.add('active');
        
        document.getElementById('molecule-title').innerText = mol.name;
        document.getElementById('molecule-desc').innerText = mol.desc;
        document.getElementById('loader').style.display = 'block';
        
        currentMolecule = mol;
        animating = false; // Stop animation on switch
        document.getElementById('simBtn').innerText = "INJECT LIGAND";

        try {
            const res = await fetch(`${API_URL}/${mol.id}`);
            const data = await res.json();
            
            points = data.points;
            center = { x: data.center[0], y: data.center[1], z: data.center[2] };
            // Reset Camera
            camera.x = 0; camera.y = 0; camera.scale = 14;
        } catch (e) {
            alert("Error loading molecule. Make sure backend is running.");
        }
        document.getElementById('loader').style.display = 'none';
    }

    // --- DRAWING ---
    function project(x, y, z) {
        const fov = 400;
        // Apply camera rotation
        let rx = x - center.x; 
        let ry = y - center.y; 
        let rz = z - center.z;

        // Rotate Y
        let tx = rx * Math.cos(camera.y) + rz * Math.sin(camera.y);
        let tz = -rx * Math.sin(camera.y) + rz * Math.cos(camera.y);
        rx = tx; rz = tz;

        // Rotate X
        let ty = ry * Math.cos(camera.x) - rz * Math.sin(camera.x);
        tz = ry * Math.sin(camera.x) + rz * Math.cos(camera.x);
        ry = ty; rz = tz;

        const scale = camera.scale;
        const dist = (rz + fov) <= 0 ? 0.001 : fov / (rz + fov);
        
        return {
            x: (rx * dist) * scale + canvas.width/2,
            y: (ry * dist) * scale + canvas.height/2,
            z: rz, // Return depth for sorting if needed
            scale: dist * scale,
            visible: rz > -300 // Simple clipping
        };
    }

    function draw() {
        // Clear
        ctx.fillStyle = "#0f0f19";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (points.length === 0) return requestAnimationFrame(draw);

        ctx.lineWidth = 2;
        let currentChain = null;
        let colorIdx = 0;

        ctx.beginPath();
        let first = true;

        for (let i = 0; i < points.length; i++) {
            let p = points[i];
            
            // Handle Chain Breaks (New color, new line)
            if (p === null || (p.chain && p.chain !== currentChain)) {
                ctx.stroke(); // Draw previous chain
                
                if (p && p.chain !== currentChain) {
                    currentChain = p.chain;
                    colorIdx = (colorIdx + 1) % CHAIN_COLORS.length;
                }
                
                ctx.strokeStyle = CHAIN_COLORS[colorIdx];
                ctx.beginPath();
                first = true;
                continue;
            }

            let proj = project(p.x, p.y, p.z);
            if (!proj.visible) continue;

            if (first) { ctx.moveTo(proj.x, proj.y); first = false; }
            else { ctx.lineTo(proj.x, proj.y); }
        }
        ctx.stroke();

        // DRAW LABELS
        if (currentMolecule && currentMolecule.labels) {
            ctx.font = "bold 12px Arial";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            
            currentMolecule.labels.forEach(lbl => {
                // Project label position relative to center
                let lx = center.x + lbl.x;
                let ly = center.y + lbl.y;
                let lz = center.z + lbl.z;
                
                let proj = project(lx, ly, lz);
                if (proj.visible) {
                    // Draw Label Box
                    let textWidth = ctx.measureText(lbl.text).width;
                    ctx.fillStyle = "rgba(0,0,0,0.7)";
                    ctx.fillRect(proj.x - textWidth/2 - 4, proj.y - 14, textWidth + 8, 18);
                    
                    // Draw Text
                    ctx.fillStyle = "#00ffc8";
                    ctx.fillText(lbl.text, proj.x, proj.y);
                    
                    // Draw Line to point
                    ctx.strokeStyle = "rgba(255,255,255,0.3)";
                    ctx.beginPath();
                    ctx.moveTo(proj.x, proj.y + 5);
                    ctx.lineTo(proj.x, proj.y + 20); // Just a little indicator line
                    ctx.stroke();
                }
            });
        }

        // DRAW ANIMATION (The "Neurotransmitter")
        if (animating) {
            animTime += 0.05;
            // Spiraling inward logic
            let radius = Math.max(5, 60 - animTime * 10); // Shrinks from 60 to 5
            let angle = animTime * 3;
            let ay = Math.sin(animTime) * 10;
            
            let ax = center.x + Math.cos(angle) * radius;
            let az = center.z + Math.sin(angle) * radius;
            let finalY = center.y + ay;

            let proj = project(ax, finalY, az);
            
            // Draw Glowing Orb
            let size = 8 * (proj.scale / 10);
            let gradient = ctx.createRadialGradient(proj.x, proj.y, 2, proj.x, proj.y, size);
            gradient.addColorStop(0, "white");
            gradient.addColorStop(1, "gold");
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
            ctx.fill();

            // Reset animation if it hits center
            if (radius <= 5) animTime = 0; 
        }

        requestAnimationFrame(draw);
    }

    // --- INTERACTIONS ---
    function toggleSimulation() {
        animating = !animating;
        document.getElementById('simBtn').innerText = animating ? "STOP SIMULATION" : "INJECT LIGAND";
        animTime = 0;
    }

    // Mouse Drag
    canvas.addEventListener('mousedown', e => { isDragging = true; lastMouse = { x: e.clientX, y: e.clientY }; });
    window.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const dx = e.clientX - lastMouse.x;
        const dy = e.clientY - lastMouse.y;
        camera.y += dx * 0.01;
        camera.x += dy * 0.01;
        lastMouse = { x: e.clientX, y: e.clientY };
    });

    // Zoom
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        camera.scale += e.deltaY * -0.01;
        camera.scale = Math.max(2, Math.min(camera.scale, 50)); // Clamp zoom
    });

    init();
</script>
</body>
</html>
