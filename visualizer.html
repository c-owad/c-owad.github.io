<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neuro-Structure Laboratory</title>
    <style>
        body { margin: 0; background-color: #0f0f19; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        
        /* SIDEBAR MENU */
        #sidebar {
            position: absolute; left: 0; top: 0; bottom: 0; width: 250px;
            background: rgba(0,0,0,0.8); border-right: 1px solid #333;
            padding: 20px; z-index: 20; display: flex; flex-direction: column;
            box-sizing: border-box; /* <--- THIS FIXES THE OVERLAP */
        }
        h2 { color: #00ffc8; margin-top: 0; font-size: 18px; text-transform: uppercase; letter-spacing: 1px; }
        .molecule-btn {
            background: #222; border: 1px solid #444; color: #ccc;
            padding: 12px; margin-bottom: 10px; cursor: pointer;
            text-align: left; border-radius: 6px; transition: 0.2s;
        }
        .molecule-btn:hover { background: #333; border-color: #00ffc8; color: white; }
        .molecule-btn.active { background: #00ffc8; color: black; border-color: #00ffc8; font-weight: bold; }

        /* MAIN CANVAS AREA */
        #canvas-container { position: absolute; left: 250px; top: 0; right: 0; bottom: 0; }
        canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        canvas:active { cursor: grabbing; }

        /* HUD OVERLAYS */
        #hud { position: absolute; top: 20px; left: 20px; pointer-events: none; }
        #molecule-title { font-size: 24px; font-weight: bold; color: white; }
        #molecule-desc { font-size: 14px; color: #00ffc8; margin-top: 5px; max-width: 400px; }

        /* CONTROLS */
        #controls { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 10px; }
        button.action-btn {
            background: #ffd700; border: none; padding: 10px 20px;
            font-weight: bold; cursor: pointer; border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        button.action-btn:hover { background: white; }

        /* LOADING SPINNER */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; color: #00ffc8; display: none;
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <h2>Select Target</h2>
        <div id="menu-list"></div>
        <div style="margin-top: auto; font-size: 12px; color: #666;">
            Scroll to Zoom<br>Drag to Rotate
        </div>
        <a href="index.html" style="color: #666; text-decoration: none; margin-top: 10px; font-size: 12px;">‚Üê Back to Portfolio</a>
    </div>

    <div id="canvas-container">
        <div id="hud">
            <div id="molecule-title">Select a Protein</div>
            <div id="molecule-desc"></div>
        </div>
        <div id="loader">Fetching Structure...</div>
        <canvas id="simCanvas"></canvas>
        
        <div id="controls">
            <button class="action-btn" onclick="toggleSimulation()" id="simBtn">INJECT LIGAND</button>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    // UPDATE THIS URL TO YOUR RENDER URL WHEN DEPLOYING
    const API_URL = "https://one5113hw4backend.onrender.com/api/molecule"; 

    // The "Database" of proteins
    const MOLECULES = [
        { 
            name: "Dopamine Receptor", 
            id: "3PBL", 
            desc: "The 'Pleasure' receptor. Primary target for antipsychotics.",
            labels: [{text: "Ligand Pocket", x: 10, y: -5, z: 0}, {text: "Helix Bundle", x: -15, y: 10, z: 5}]
        },
        { 
            name: "Serotonin Transporter", 
            id: "5I6X", 
            desc: "Regulates mood and anxiety. Target of SSRI antidepressants.",
            labels: [{text: "Central Cavity", x: 0, y: 0, z: 0}]
        },
        { 
            name: "GABA Receptor", 
            id: "4COF", 
            desc: "The 'Calm' receptor. Activated by sedatives and alcohol.",
            labels: [{text: "Ion Channel", x: 0, y: 20, z: 0}]
        },
        { 
            name: "Adrenaline Receptor", 
            id: "3SN6", 
            desc: "Triggers the 'Fight or Flight' response.",
            labels: [{text: "G-Protein Interface", x: 0, y: -30, z: 0}]
        }
    ];

    // Colors for different chains (Cyan, Purple, Green, Orange)
    const CHAIN_COLORS = ["#00ffc8", "#bd00ff", "#00ff00", "#ff8800"];

    // --- STATE ---
    let points = [];
    let currentMolecule = null;
    let center = {x: 0, y: 0, z: 0};
    let camera = { x: 0, y: 0, scale: 14 };
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };
    
    // Animation State
    let animating = false;
    let animTime = 0;

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    // --- INITIALIZATION ---
    function init() {
        // Build Menu
        const menu = document.getElementById('menu-list');
        MOLECULES.forEach(mol => {
            const btn = document.createElement('div');
            btn.className = 'molecule-btn';
            btn.innerText = mol.name;
            btn.onclick = () => loadMolecule(mol, btn);
            menu.appendChild(btn);
        });

        // Resize Handling
        window.addEventListener('resize', resize);
        resize();

        // Start Loop
        requestAnimationFrame(draw);
    }

    function resize() {
        canvas.width = document.getElementById('canvas-container').offsetWidth;
        canvas.height = document.getElementById('canvas-container').offsetHeight;
    }

    // --- CORE LOGIC ---
    async function loadMolecule(mol, btnElement) {
        // UI Updates
        document.querySelectorAll('.molecule-btn').forEach(b => b.classList.remove('active'));
        if(btnElement) btnElement.classList.add('active');
        
        document.getElementById('molecule-title').innerText = mol.name;
        document.getElementById('molecule-desc').innerText = mol.desc;
        document.getElementById('loader').style.display = 'block';
        
        currentMolecule = mol;
        animating = false; // Stop animation on switch
        document.getElementById('simBtn').innerText = "INJECT LIGAND";

        try {
            const res = await fetch(`${API_URL}/${mol.id}`);
            const data = await res.json();
            
            points = data.points;
            center = { x: data.center[0], y: data.center[1], z: data.center[2] };
            // Reset Camera
            camera.x = 0; camera.y = 0; camera.scale = 14;
        } catch (e) {
            alert("Error loading molecule. Make sure backend is running.");
        }
        document.getElementById('loader').style.display = 'none';
    }

    // --- DRAWING ---
    function project(x, y, z) {
        const fov = 400;
        // Apply camera rotation
        let rx = x - center.x; 
        let ry = y - center.y; 
        let rz = z - center.z;

        // Rotate Y
        let tx = rx * Math.cos(camera.y) + rz * Math.sin(camera.y);
        let tz = -rx * Math.sin(camera.y) + rz * Math.cos(camera.y);
        rx = tx; rz = tz;

        // Rotate X
        let ty = ry * Math.cos(camera.x) - rz * Math.sin(camera.x);
        tz = ry * Math.sin(camera.x) + rz * Math.cos(camera.x);
        ry = ty; rz = tz;

        const scale = camera.scale;
        const dist = (rz + fov) <= 0 ? 0.001 : fov / (rz + fov);
        
        return {
            x: (rx * dist) * scale + canvas.width/2,
            y: (ry * dist) * scale + canvas.height/2,
            z: rz, // Return depth for sorting if needed
            scale: dist * scale,
            visible: rz > -300 // Simple clipping
        };
    }

    function draw() {
        // Clear screen
        ctx.fillStyle = "#0f0f19";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (points.length === 0) return requestAnimationFrame(draw);

        ctx.lineWidth = 2;
        let currentChain = null;
        let colorIdx = 0;
        
        // Start the path
        ctx.beginPath();
        ctx.strokeStyle = CHAIN_COLORS[0]; // Default color
        let first = true;

        for (let i = 0; i < points.length; i++) {
            let p = points[i];
            
            // 1. Handle "Breaks" (Null points from Python)
            if (p === null) {
                ctx.stroke();     // Finish previous line
                ctx.beginPath();  // Start new line
                first = true;
                continue;
            }

            // 2. DATA COMPATIBILITY FIX
            // If p is an array [x,y,z] (Old Backend), convert it to object
            let px, py, pz, pChain;
            if (Array.isArray(p)) {
                px = p[0]; py = p[1]; pz = p[2]; pChain = 'A';
            } else {
                px = p.x; py = p.y; pz = p.z; pChain = p.chain;
            }

            // 3. Handle Chain Color Changes
            if (pChain && pChain !== currentChain) {
                // If we are already drawing, finish the old color line first
                if (currentChain !== null) {
                    ctx.stroke();
                    ctx.beginPath();
                    // Reset 'first' so we move to the start of the new chain without drawing a stray line
                    first = true; 
                    
                    // Cycle to next color
                    colorIdx = (colorIdx + 1) % CHAIN_COLORS.length;
                    ctx.strokeStyle = CHAIN_COLORS[colorIdx];
                }
                currentChain = pChain;
            }

            // 4. Project 3D to 2D
            let proj = project(px, py, pz);
            if (!proj.visible) continue;

            // 5. Draw
            if (first) { 
                ctx.moveTo(proj.x, proj.y); 
                first = false; 
            } else { 
                ctx.lineTo(proj.x, proj.y); 
            }
        }
        ctx.stroke(); // Draw the final segment

        // --- DRAW LABELS & ANIMATIONS (Kept same as before) ---
        drawLabelsAndLigand(); 
        
        requestAnimationFrame(draw);
    }

    // Move the label logic to a helper to keep draw() clean
// --- UPDATED HELPER FUNCTION ---
    function drawLabelsAndLigand() {
        // 1. DRAW LABELS (Kept the same)
        if (currentMolecule && currentMolecule.labels) {
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "center";
            
            currentMolecule.labels.forEach(lbl => {
                let lx = center.x + lbl.x;
                let ly = center.y + lbl.y;
                let lz = center.z + lbl.z;
                
                let proj = project(lx, ly, lz);
                if (proj.visible) {
                    let textWidth = ctx.measureText(lbl.text).width;
                    ctx.fillStyle = "rgba(0,0,0,0.7)";
                    ctx.fillRect(proj.x - textWidth/2 - 4, proj.y - 14, textWidth + 8, 18);
                    ctx.fillStyle = "#00ffc8";
                    ctx.fillText(lbl.text, proj.x, proj.y);
                    ctx.strokeStyle = "rgba(255,255,255,0.3)";
                    ctx.beginPath(); ctx.moveTo(proj.x, proj.y + 5); ctx.lineTo(proj.x, proj.y + 20); ctx.stroke();
                }
            });
        }

        // 2. NEW REALISTIC LIGAND ANIMATION
        if (animating) {
            // A. Calculate Progress (0.0 to 1.0)
            // We increment animTime slower for a smoother approach
            if (animTime < 1.0) {
                animTime += 0.008; 
            }
            
            // B. Define Start (Outside) and End (Center)
            // Start high up and slightly offset
            const startX = center.x + 40;
            const startY = center.y - 80;
            const startZ = center.z + 20;

            const endX = center.x;
            const endY = center.y;
            const endZ = center.z;

            // C. Interpolate (Lerp) position
            // 't' is our eased progress (starts fast, slows down at end)
            let t = animTime;
            let ease = 1 - Math.pow(1 - t, 3); // Cubic Ease Out

            let currX = startX + (endX - startX) * ease;
            let currY = startY + (endY - startY) * ease;
            let currZ = startZ + (endZ - startZ) * ease;

            // D. Add "Brownian Motion" (Jitter)
            // Real molecules jitter. We add small sin/cos offsets based on time
            let jitter = (1.0 - ease) * 5; // Jitter reduces as it docks
            currX += Math.sin(Date.now() * 0.005) * jitter;
            currY += Math.cos(Date.now() * 0.005) * jitter;

            // E. Draw the Ligand
            let proj = project(currX, currY, currZ);
            
            // Pulse size when docked
            let pulse = (animTime >= 1.0) ? Math.sin(Date.now() * 0.005) * 2 : 0;
            let size = (8 + pulse) * (proj.scale / 10);

            // Draw Glow
            let gradient = ctx.createRadialGradient(proj.x, proj.y, 2, proj.x, proj.y, size * 2);
            gradient.addColorStop(0, "rgba(255, 215, 0, 1)");   // Solid Gold center
            gradient.addColorStop(0.4, "rgba(255, 215, 0, 0.4)"); // Semi-transparent gold
            gradient.addColorStop(1, "rgba(255, 215, 0, 0)");    // Fade out

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, size * 2, 0, Math.PI * 2);
            ctx.fill();

            // Draw Core
            ctx.fillStyle = "#ffd700";
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, size * 0.6, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // --- INTERACTIONS ---
    function toggleSimulation() {
        animating = !animating;
        document.getElementById('simBtn').innerText = animating ? "RESET SIMULATION" : "INJECT LIGAND";
        animTime = 0; // Reset progress to start
    }

    // Mouse Drag
    canvas.addEventListener('mousedown', e => { isDragging = true; lastMouse = { x: e.clientX, y: e.clientY }; });
    window.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const dx = e.clientX - lastMouse.x;
        const dy = e.clientY - lastMouse.y;
        camera.y += dx * 0.01;
        camera.x += dy * 0.01;
        lastMouse = { x: e.clientX, y: e.clientY };
    });

    // Zoom
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        camera.scale += e.deltaY * -0.01;
        camera.scale = Math.max(2, Math.min(camera.scale, 50)); // Clamp zoom
    });

    init();
</script>
</body>
</html>
